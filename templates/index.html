<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Z√© do Financeiro - Seu Guia de Bolso!</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/estilo.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            <img src="{{ url_for('static', filename='img/logo_ze_financeiro.png') }}" alt="Logo Z√© do Financeiro" id="chatLogo"> 
            <h2>Z√© do Financeiro</h2>
            <p>Seu guia de bolso para o microempreendedor digitalizado!</p>
        </div>
        <div class="chat-messages" id="chatMessages">
            </div>
        <div class="chat-input">
            <input type="text" id="userInput" placeholder="Digite sua mensagem aqui...">
            <button id="sendButton">Enviar</button>
        </div>
    </div>

    <script>
        const chatMessages = document.getElementById('chatMessages');
        const userInput = document.getElementById('userInput');
        const sendButton = document.getElementById('sendButton');
        let loadingMessageDiv = null; // Para controlar a mensagem de "pensando..."
        let userName = localStorage.getItem('userName'); // Pega nome do usu√°rio do localStorage
        let esperandoNome = false; // Flag para controlar se estamos aguardando o nome

        const NOME_CHATBOT_FRONTEND = "Z√© do Financeiro"; // Nome do bot para exibi√ß√£o
        const CHAT_HISTORY_KEY = 'zeDoFinanceiroChatHistory'; // Chave para o localStorage do hist√≥rico

        // Fun√ß√£o para obter o hist√≥rico do localStorage
        function getChatHistory() {
            const history = localStorage.getItem(CHAT_HISTORY_KEY);
            return history ? JSON.parse(history) : [];
        }

        // Fun√ß√£o para salvar uma nova mensagem no hist√≥rico
        function saveMessageToHistory(text, sender, timestamp) {
            const history = getChatHistory();
            history.push({ text, sender, timestamp });
            localStorage.setItem(CHAT_HISTORY_KEY, JSON.stringify(history));
        }

        // Fun√ß√£o para adicionar mensagem ao chat
        function addMessage(text, sender, timestamp = new Date().toISOString(), fromHistory = false) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message');
            
            // Usa o nome do usu√°rio se existir, sen√£o usa "Voc√™"
            const displayName = sender === 'user' ? (userName || 'Voc√™') : NOME_CHATBOT_FRONTEND;

            const strong = document.createElement('strong');
            strong.textContent = `${displayName}:`;
            messageDiv.appendChild(strong);
            
            const contentDiv = document.createElement('div');
            contentDiv.style.display = 'inline'; // Para conte√∫do ficar ao lado do nome

            if (sender === 'user') {
                messageDiv.classList.add('user-message');
                // Adiciona o texto do usu√°rio como n√≥ de texto para evitar renderiza√ß√£o de HTML
                contentDiv.appendChild(document.createTextNode(" " + text));
            } else { // sender === 'bot'
                messageDiv.classList.add('bot-message');
                // Converte o texto do bot de Markdown para HTML
                contentDiv.innerHTML = (typeof marked !== 'undefined') ? marked.parse(text || "") : (text || "");
            }
            messageDiv.appendChild(contentDiv);

            // Adicionar timestamp
            const timeElement = document.createElement('span');
            timeElement.style.fontSize = '0.75em';
            timeElement.style.opacity = '0.7';
            timeElement.style.display = 'block';
            timeElement.style.textAlign = (sender === 'user') ? 'right' : 'left';
            timeElement.style.marginTop = '5px';
            try {
                timeElement.textContent = new Date(timestamp).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
            } catch (e) { // Fallback se o timestamp for inv√°lido
                timeElement.textContent = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
            }
            messageDiv.appendChild(timeElement);
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight; 

            if (!fromHistory) { // Salva no hist√≥rico apenas se n√£o for uma mensagem sendo carregada do hist√≥rico
                saveMessageToHistory(text, sender, timestamp);
            }
        }

        // Fun√ß√£o para mostrar o indicador de carregamento
        function showLoadingIndicator() {
            if (loadingMessageDiv) { 
                loadingMessageDiv.remove();
            }
            loadingMessageDiv = document.createElement('div');
            loadingMessageDiv.classList.add('message', 'bot-message', 'loading-indicator'); 
            
            const strong = document.createElement('strong');
            strong.textContent = `${NOME_CHATBOT_FRONTEND}:`;
            loadingMessageDiv.appendChild(strong);

            const content = document.createElement('div');
            content.style.display = 'inline';
            content.innerHTML = ' Estou pensando um cadinho, ' + (userName || 'meu patr√£o/minha patroa') + '... üß†'; 
            loadingMessageDiv.appendChild(content);
            
            chatMessages.appendChild(loadingMessageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Fun√ß√£o para esconder o indicador de carregamento
        function hideLoadingIndicator() {
            if (loadingMessageDiv) {
                loadingMessageDiv.remove();
                loadingMessageDiv = null; 
            }
        }

        // Fun√ß√£o para enviar mensagem para o backend
        async function sendMessageToBot(messageText) {
            const userMessageTimestamp = new Date().toISOString();

            // Se estiver esperando o nome do usu√°rio
            if (esperandoNome) {
                const nomeDigitado = messageText.trim();
                if (nomeDigitado) {
                    userName = nomeDigitado; 
                    localStorage.setItem('userName', userName); 
                    addMessage(userName, 'user', userMessageTimestamp); // Mostra o nome que o usu√°rio digitou
                    
                    esperandoNome = false;
                    userInput.placeholder = "Digite sua mensagem aqui...";
                    userInput.value = ''; 
                    
                    const botWelcomeWithName = `Prazer em te conhecer, ${userName}! Em que posso te ajudar agora?`;
                    addMessage(botWelcomeWithName, 'bot', new Date().toISOString()); 
                    
                    // Envia o nome para o backend para registrar na sess√£o Flask
                    try {
                        console.log(`[FRONTEND] Enviando nome '${userName}' para o backend...`);
                        const responseNome = await fetch('/webhook', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ nome_usuario: userName, mensagem: "REGISTRO_DE_NOME_USUARIO" }),
                        });
                        if (!responseNome.ok) {
                            console.error("[FRONTEND] Erro ao registrar nome no backend:", responseNome.statusText);
                        } else {
                            const dataNome = await responseNome.json();
                            console.log("[FRONTEND] Resposta do backend ao registrar nome:", dataNome);
                            // Se o backend confirmar com uma mensagem, poderia ser adicionada aqui
                            // Ex: if (dataNome.resposta_bot && dataNome.resposta_bot !== `Beleza, ${userName}! Nome registrado...`) { addMessage(dataNome.resposta_bot, 'bot'); }
                        }
                    } catch (error) {
                        console.error('[FRONTEND] Erro ao enviar nome para o backend:', error);
                    }
                    userInput.focus();
                    return; 
                } else {
                    addMessage("Oxe, parece que voc√™ n√£o digitou um nome. Pode tentar de novo?", 'bot', new Date().toISOString());
                    userInput.focus();
                    return; 
                }
            }

            // Fluxo normal de envio de mensagem
            addMessage(messageText, 'user', userMessageTimestamp);
            userInput.value = ''; 
            userInput.disabled = true;
            sendButton.disabled = true;
            showLoadingIndicator();

            try {
                const fetchOptions = {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mensagem: messageText, nome_usuario: userName }) // Envia nome_usuario sempre
                };
                
                const response = await fetch('/webhook', fetchOptions);
                
                hideLoadingIndicator(); 

                if (!response.ok) {
                    throw new Error(`Erro na requisi√ß√£o: ${response.status} ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data && data.resposta_bot) {
                    addMessage(data.resposta_bot, 'bot', new Date().toISOString());
                } else {
                    addMessage("O Z√© n√£o conseguiu processar essa, tente de novo ou de outra forma.", 'bot', new Date().toISOString());
                }

            } catch (error) {
                hideLoadingIndicator(); 
                console.error('[FRONTEND] Erro ao enviar mensagem:', error);
                addMessage(`Oxe, deu um piripaque na minha conex√£o com o Z√©! (Erro: ${error.message})`, 'bot', new Date().toISOString());
            } finally {
                userInput.disabled = false;
                sendButton.disabled = false;
                userInput.focus();
            }
        }

        // L√≥gica de inicializa√ß√£o do chat
        function iniciarChat() {
            // Limpa mensagens existentes na tela para n√£o duplicar ao carregar hist√≥rico
            chatMessages.innerHTML = ''; 
            
            const chatHistory = getChatHistory();
            chatHistory.forEach(msg => {
                addMessage(msg.text, msg.sender, msg.timestamp, true); // true indica que √© do hist√≥rico
            });

            if (userName) { // Se tem nome no localStorage
                // Se o hist√≥rico estava vazio, mas temos nome, significa que √© um retorno do usu√°rio
                // e o backend j√° deve ter sido informado ou ser√° informado na primeira mensagem.
                // A sauda√ß√£o inicial do backend j√° usar√° o nome.
                // Podemos adicionar uma mensagem de "Bem-vindo de volta" do frontend se o hist√≥rico estiver vazio.
                if (chatHistory.length === 0) {
                    addMessage(`De volta, ${userName}! Sou o ${NOME_CHATBOT_FRONTEND}. Em que posso te ajudar hoje?`, 'bot', new Date().toISOString(), true); // Adiciona ao hist√≥rico visual, mas n√£o salva de novo
                }
                userInput.placeholder = "Digite sua mensagem aqui...";
                // Garante que o backend tem o nome na sess√£o (caso a sess√£o Flask tenha expirado)
                 fetch('/webhook', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ nome_usuario: userName, mensagem: "REINICIO_SESSAO_COM_NOME" })
                 });
            } else { // Se n√£o tem nome no localStorage
                 // Se n√£o tem nome E n√£o tem hist√≥rico, pede o nome.
                if (chatHistory.length === 0) {
                    addMessage(`Ol√°! Sou o ${NOME_CHATBOT_FRONTEND}. Para nosso papo ficar mais arretado, como posso te chamar?`, 'bot', new Date().toISOString(), true); // Adiciona ao hist√≥rico visual
                    userInput.placeholder = "Digite seu nome aqui...";
                    esperandoNome = true;
                } else {
                    // Tem hist√≥rico mas por algum motivo perdeu o nome no localStorage (raro)
                    // Pode pedir o nome novamente ou apenas deixar o placeholder padr√£o.
                    userInput.placeholder = "Digite sua mensagem aqui...";
                }
            }
            userInput.focus();
        }

        // Event listener para o bot√£o de enviar
        sendButton.addEventListener('click', () => {
            const messageText = userInput.value.trim();
            if (messageText) {
                sendMessageToBot(messageText);
            }
        });

        // Event listener para a tecla Enter no campo de input
        userInput.addEventListener('keypress', (event) => {
            if (event.key === 'Enter') {
                event.preventDefault(); // Evita o comportamento padr√£o do Enter (que poderia ser submeter um formul√°rio)
                const messageText = userInput.value.trim();
                if (messageText) {
                    sendMessageToBot(messageText);
                }
            }
        });

        // Inicia o chat quando a p√°gina carrega
        iniciarChat();
    </script>
</body>
</html>